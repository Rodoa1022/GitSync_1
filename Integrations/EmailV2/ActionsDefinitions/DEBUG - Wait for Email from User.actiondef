{"Name":"DEBUG - Wait for Email from User","Description":"Wait for user's response based on an email sent via Send Email action. Note: This is a Siemplify async action, if required, please adjust the async timeout for action (polling timeout) and global action timeout as needed. Action input parameter “Wait stage timeout (minutes)“ cant be larger than global timeout. Note: Please make sure to set IDE timeout as well, as the IDE timeout will override the action’s timeout if the IDE timeout will be shorter. Requires: IMAP configuration","Script":"# -*- coding: utf-8 -*-\nimport json\nimport re\nimport arrow\nimport os\nfrom datetime import timedelta\nfrom SiemplifyUtils import utc_now, output_handler\nfrom ScriptResult import EXECUTION_STATE_COMPLETED, EXECUTION_STATE_INPROGRESS, EXECUTION_STATE_TIMEDOUT\nfrom EmailCommon import safe_str_cast, save_attachments_to_case\nfrom EmailActions import EmailIMAPAction\nfrom EmailFileManager import save_attachments_locally\n\n\ndef should_response_be_excluded(email, body_exclude_pattern):\n    \"\"\"\n    Get first message content from list which is not matching patterns.\n    :param email: {dict} EmailModel object. Email body must be utf-8 encoded.\n    :param body_exclude_pattern: {string} Subject regex exclude pattern.\n    :return: {string} Relevant reply.\n    \"\"\"\n    if not body_exclude_pattern:\n        return False\n\n    if email.body:\n        # Message received as utf-8 encoded string - treated when receiving message.\n        body_exclude_match = re.compile(body_exclude_pattern).match(email.body)\n        if body_exclude_match:\n            return True\n    return False\n\n\nclass WaitForEmailFromUserAction(EmailIMAPAction):\n    \"\"\"\n    This class should be used to await for responses to an email earlier sent by SendEmail action.\n    WaitForEmailFromUser action should monitor target mailbox by IMAP for responses to email sent earlier.\n    \"\"\"\n\n    SCRIPT_NAME = \"EmailV2 - Wait for Email from User\"\n\n    CONF_IMAP_SERVER_ADDRESS = \"IMAP Server Address\"  # IMAP Server Address, e.g. imap.gmail.com\n    CONF_IMAP_PORT = \"IMAP Port\"  # Port to connect to IMAP Server, e.g. 993\n    CONF_IMAP_USE_SSL = \"IMAP USE SSL\"\n\n    DEFAULT_RESOLVED_BODY = \"Message Has No Body.\"\n    DEFAULT_TIMEOUT_MESSAGE = \"Timeout\"\n\n    def __init__(self):\n        \"\"\"\n        WaitForEmailFromUserAction constructor.\n        \"\"\"\n        super(WaitForEmailFromUserAction, self).__init__(WaitForEmailFromUserAction.SCRIPT_NAME)\n\n    # noinspection PyAttributeOutsideInit\n    def load_action_configuration(self):\n        \"\"\"\n        Protected method, which should load configuration, specific to the SendEmail Action\n        \"\"\"\n        self.timeout = self._get_action_param(param_name=\"Wait stage timeout (minutes)\",\n                                              input_type=int,\n                                              default_value=1440)\n        self.wait_for_all_recipients = self._get_action_param(param_name=\"Wait for all recipients to reply?\",\n                                                              input_type=bool)\n        self.body_exclude_pattern = self._get_action_param(param_name=\"Wait stage exclude pattern\")\n        folders_string = self._get_action_param(param_name=\"Folder to check for reply\",\n                                                default_value=\"Inbox\")\n        self.folders = [f.strip() for f in folders_string.split(\",\") if f.strip()] if folders_string else []\n        self.fetch_attachments = self._get_action_param(param_name=\"Fetch Response Attachments\",\n                                                        input_type=bool,\n                                                        default_value=False)\n\n        self.message_id = self._get_action_param(param_name=\"Email Message_id\",\n                                                 is_mandatory=True)\n        email_date_string = self._get_action_param(param_name=\"Email Date\",\n                                                   is_mandatory=True)\n        self.email_date = arrow.get(email_date_string) if email_date_string else arrow.utcnow()\n\n        recipients_string = self._get_action_param(param_name=\"Email Recipients\",\n                                                   is_mandatory=True)\n        if recipients_string:\n            self.recipients = [address.strip() for address in recipients_string.split(\",\") if address.strip()]\n        else:\n            self.recipients = []\n        if not self.recipients:\n            raise AttributeError(\"Send Email recipients list can't be empty.\")\n\n    # noinspection PyUnusedLocal\n    def execute_action(self, output_messages, successful_entities, failed_entities):\n        \"\"\"\n        Pulls mailbox via IMAP to find email responses to email sent earlier\n        :param output_messages: {list} Mutable list of output messages (str) to form audit trail for this action\n        :param successful_entities: {list} N/A in case of SendEmail. List of entity.identifier's, which have been processed successfully\n        :param failed_entities: {list} N/A in case of SendEmail. List of entity.identifier's, which have been failed during processing\n        :return: {tuple} 1st value - Status of the operation: {int} 0 - success, 1 - failed, 2 - timed out; 2nd value - Success flag: {bool} True - success, False - failure.\n        \"\"\"\n        email_list = []\n        print(\"EMAIL LIST: \", email_list)\n        attachments = {}\n        for folder, email_uid in self.search_emails(folders=self.folders, reply_to=self.message_id):\n            self.logger.info(\"Fetching email with email_uid={0} in folder={1}\".format(\n                email_uid, folder))\n            email = self.email_imap_manager.get_message_data_by_message_id(\n                email_uid=email_uid,\n                folder_name=folder,\n                mark_as_read=True)\n            if not email:\n                self.logger.info(\"No emails were found for email_uid={0} in folder={1}\".format(\n                    email_uid, folder))\n                continue\n            self.logger.info(\"Fetched email successfully with email_uid={0} and message_id={1}\".format(\n                email_uid, email.message_id))\n            email_list.append(email)\n\n            if self.fetch_attachments:\n                try:\n                    attachments_paths = save_attachments_locally(self.siemplify.run_folder, email.attachments)\n                    self.logger.info(\"Saved attachments locally for email_uid={}\".format(email_uid))\n                    attachments.update({email_uid: attachments_paths})\n                except Exception as e:\n                    self.logger.error(\"Unable to save attachments locally\".format(\n                        email_uid, folder))\n                    self.logger.exception(e)\n\n        self.siemplify.LOGGER.info(\n            \"Running on recipients: {0}, message ID: {1}\".format(\n                \",\".join(self.recipients),\n                self.message_id))\n        recipients_responses = self.__find_email_per_recipient(email_list, self.recipients)\n        self.logger.info(\"Gathered responses: {}\".format([k for k, v in list(recipients_responses.items()) if v]))\n\n        is_timeout = self.__is_timeout(self.recipients, recipients_responses)\n        if is_timeout:\n            self.logger.info(\"There are timed out responses\")\n            recipients_responses = self.__process_timeouts(self.recipients, recipients_responses)\n\n        if self.fetch_attachments:\n            save_attachments_to_case(self.siemplify, attachments)\n            self.logger.info(\"Saved all attachments: {}\".format(attachments))\n\n        self.siemplify.result.add_result_json({\"Responses\": self.__construct_json_results(recipients_responses)})\n\n        if is_timeout:\n            message = \"Timeout getting replies from users\"\n            output_messages.append(message)\n            self.logger.info(message)\n            return EXECUTION_STATE_TIMEDOUT, False\n        elif not self.is_processing_completed(self.recipients, recipients_responses, self.wait_for_all_recipients):\n            message = \"Continuing...waiting for response, searching IN-REPLY-TO {0}\".format(self.message_id)\n            output_messages.append(message)\n            self.logger.info(message)\n            return EXECUTION_STATE_INPROGRESS, True\n        else:\n            message = u\"Received all responses\"\n            output_messages.append(message)\n            self.logger.info(message)\n            return EXECUTION_STATE_COMPLETED, True\n\n    def __is_timeout(self, recipients, recipients_responses):\n        \"\"\"\n        Identifies if there are any missing & timed out responses\n        :param recipients: {list} List of recipient email addresses\n        :param recipients_responses: {dict} Dictionary with all available and valid (not OOO) responses from the email recipients\n        :return: True - in case of any responses are missing and timeout. False - otherwise.\n        \"\"\"\n        if self.email_date + timedelta(minutes=self.timeout) < utc_now():\n            are_responses_missing = False\n            for r in recipients:\n                if not recipients_responses.get(r):\n                    are_responses_missing = True\n                    break\n            if are_responses_missing:\n                return True\n\n        return False\n\n    def __process_timeouts(self, recipients, recipients_responses):\n        \"\"\"\n        Updates all timeout responses with default message\n        :param recipients: {list} List of recipient email addresses\n        :param recipients_responses: {dict} Dictionary with all available and valid (not OOO) responses from the email recipients\n        :return: {dict} Updated responses dictionary with time out messages\n        \"\"\"\n        responses = dict(recipients_responses)\n\n        if self.email_date + timedelta(minutes=self.timeout) < utc_now():\n            for r in recipients:\n                if not responses.get(r):\n                    self.logger.info(\"Timeout getting reply from user: {0}\".format(r))\n                    responses[r] = self.DEFAULT_TIMEOUT_MESSAGE\n\n        return responses\n\n    def is_processing_completed(self, recipients, recipients_responses, wait_for_all_recipients):\n        \"\"\"\n        Identifies if email processing has been completed\n        :param recipients: {list} List of recipient email addresses\n        :param recipients_responses: {dict} Dictionary with all available and valid (not OOO) responses from the email recipients\n        :param wait_for_all_recipients: {bool} In some cases just first response from the any recipient is enough. If this is the case, then this parameter should be True.\n        :return: True - we have successfully received all the responses. False - otherwise.\n        \"\"\"\n        def __is_one_response_at_least():\n            for r in recipients:\n                response = recipients_responses.get(r)\n                if response and response != self.DEFAULT_TIMEOUT_MESSAGE:\n                    return True\n            return False\n\n        def __is_full_response():\n            for r in recipients:\n                if not recipients_responses.get(r):\n                    return False\n                elif recipients_responses.get(r) == self.DEFAULT_TIMEOUT_MESSAGE:\n                    return False\n            return True\n\n        if not wait_for_all_recipients:\n            return __is_one_response_at_least()\n\n        return __is_full_response()\n\n    def __find_email_per_recipient(self, emails_list, recipients_list):\n        \"\"\"\n        Reviews list of emails found on the server and maps each to a recipient from the list\n        :param emails_list: {list} List of EmailModel objects\n        :param recipients_list: {list} List of recipient emails\n        :return: {dict} Map of recipients responses.\n        \"\"\"\n        recipients_responses = {}\n\n        for recipient in recipients_list:\n            self.logger.info(\n                \"Running on recipient: {0}\".format(recipient))\n\n            email = self.__get_user_first_valid_message(\n                sender=recipient,\n                emails_list=emails_list,\n                body_exclude_pattern=self.body_exclude_pattern)\n\n            if email and email.body:\n                self.logger.info(\n                    \"Got email for recipient: {0}\".format(recipient))\n                recipients_responses[recipient] = email.body\n            else:\n                recipients_responses[recipient] = None\n\n        return recipients_responses\n\n    def __get_user_first_valid_message(self,\n                                       sender,\n                                       emails_list,\n                                       body_exclude_pattern=None):\n        \"\"\"\n        Get all messages sent by recipient.\n        :param sender: {string} Sender address.\n        :param email_list: {list} List of EmailModel objects\n        :param body_exclude_pattern: {string} subject regex exclude pattern.\n        :return: {list} list of relevant message dicts.\n        \"\"\"\n        if not emails_list or len(emails_list) == 0:\n            return None\n\n        senders_messages = [message for message in emails_list if\n                            message.last_email_sender.lower() == sender.lower()]\n\n        self.logger.info(\"Found {0} messages for sender {1}\".format(len(senders_messages), sender))\n\n        try:\n            senders_messages = sorted(senders_messages, key=lambda i: i.email_date)\n        except Exception as err:\n            self.logger.error(\"Messages does not contain date key.\")\n            self.logger.exception(err)\n\n        for sequence, message in enumerate(senders_messages):\n            self.logger.info(\n                'Checking message match exclude pattern for sender: {0}, message sequence:{1}'.format(sender,\n                                                                                                      sequence + 1))\n            if not should_response_be_excluded(message, body_exclude_pattern):\n                self.logger.info(\"Message in sequence {0} for sender {1} is valid.\".format(sequence + 1, sender))\n                return message\n            else:\n                self.logger.info(\"Message in sequence {0} for sender {1} is not valid.\".format(sequence + 1, sender))\n                continue\n        return None\n\n    def __build_result_objects(self, email):\n        \"\"\"\n        Generate output message from received email.\n        output_message should be first email body (full thread) + handle unicode/str encoding as needed\n        :param message: {EmailModel} Received message dict.\n        :return: {tuple} Action output and result value.\n        \"\"\"\n        body = email.body if email.body else self.DEFAULT_RESOLVED_BODY\n        body = safe_str_cast(body, self.DEFAULT_RESOLVED_BODY)\n\n        try:\n            # Extract response content without the forwarding part\n            result_value = body[:(body.index('<'))]\n        except Exception as e:\n            self.logger.error(\"Failed to extract response content without the forwarding part\")\n            self.logger.exception(str(e))\n            result_value = body\n\n        output_message = \"Response:\\n{0}\".format(body)\n\n        return output_message, result_value\n\n    def __construct_json_results(self, recipients_responses):\n        \"\"\"\n        Create a JSON results object out of the recipients responses\n        :param recipients_responses: {dict} The recipients responses\n        :return: {list} The constructed JSON results\n        \"\"\"\n        json_results = []\n\n        for recipient, response in list(recipients_responses.items()):\n            json_results.append({\n                \"recipient\": recipient,\n                \"content\": response\n            })\n\n        return json_results\n\n@output_handler\ndef main():\n    action = WaitForEmailFromUserAction()\n    action.run()\n\n\nif __name__ == \"__main__\":\n    main()\n","IntegrationIdentifier":"EmailV2","ScriptResultName":"is_success","DynamicResultsMetadata":[{"ResultName":"JsonResult","ResultExample":"{\"Responses\": [{\"recipient\": \"aaa@aaa.com\", \"content\": \"It's approved, John!\"}, {\"recipient\": \"xxx@xxx.com\", \"content\": \"I approve going forward on this\"}]}","ShowResult":true}],"Creator":"1f518f8f-d493-4942-a968-ef08800f5d24","IsEnabled":true,"IsCustom":true,"IsSystem":false,"Version":4.0,"TimeoutSeconds":600,"IsAsync":true,"AsyncPollingIntervalInSeconds":30,"TotalIntervalTimeoutForAsyncInSeconds":90,"Parameters":[{"CustomActionId":0,"IsMandatory":true,"DefaultValue":"","Description":"Comma-separated list of recipient emails, response from which current action would be waiting for. If message has been sent using Send Email action, please select Select SendEmail.JSONResult.recipients field as a placeholder.","Name":"Email Recipients","Value":"","Type":0,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":true,"DefaultValue":"1440","Description":"How long in minutes to wait for the user’s reply before marking it timed out.","Name":"Wait stage timeout (minutes)","Value":"1440","Type":0,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":false,"DefaultValue":"True","Description":"Parameter can be used to define if there are multiple recipients - should the Action wait for responses from all of recipients until timeout, or Action should wait for first reply to proceed.","Name":"Wait for all recipients to reply?","Value":"True","Type":1,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":false,"DefaultValue":"","Description":"Regular expression to exclude specific replies from the wait stage. Works with body part of email. Example is, to exclude automatic Out-Of-Office emails to be considered as recipient reply, and instead wait for actual user reply","Name":"Wait stage exclude pattern","Value":"","Type":0,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":false,"DefaultValue":"Inbox","Description":"Parameter can be used to specify mailbox email folder (mailbox that was used to send the email with question) to search for the user reply in this folder. Parameter should also accept comma separated list of folders to check the user response in multiple folders. Parameter is case sensitive.","Name":"Folder to check for reply","Value":"Inbox","Type":0,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":false,"DefaultValue":"False","Description":"If selected, if recipient replies with attachment – fetch recipient response and add it as attachment for the action result.","Name":"Fetch Response Attachments","Value":"False","Type":1,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":true,"DefaultValue":"","Description":"Message_id of the email, which current action would be waiting for. If message has been sent using Send Email action, please select SendEmail.JSONResult.message_id field as a placeholder.","Name":"Email Message_id","Value":"","Type":0,"OptionalValues":null,"OptionalValuesJson":null},{"CustomActionId":0,"IsMandatory":true,"DefaultValue":"","Description":"Send timestamp of the email, which current action would be waiting for. If message has been sent using Send Email action, please select SendEmail.JSONResult.email_date field as a placeholder.","Name":"Email Date","Value":"","Type":0,"OptionalValues":null,"OptionalValuesJson":null}],"DefaultResultValue":null,"PythonVersion":"None","SimulationData":{"Entities":null},"SimulationDataJson":null}