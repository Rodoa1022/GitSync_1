{
    "isUpdateAvailable": false,
    "isCustom": true,
    "isEnabled": true,
    "isRemoteConnector": false,
    "environment": "Default Environment",
    "integration": "EmailV2",
    "identifier": "Generic IMAP Email Connector_055e3705-f92d-46d5-8f27-56eedf174c78",
    "connectorDefinitionName": "Generic IMAP Email Connector",
    "displayName": "Generic IMAP Email Connector",
    "description": "",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "2",
    "pythonVersion": 2,
    "isAllowlistSupported": false,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Folder to check for emails",
            "paramValue": "Inbox",
            "description": "Parameter can be used to specify email folder on the mailbox to search for the emails. Parameter should also accept comma separated list of folders to check the user response in multiple folders. Parameter is case sensitive.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Server Time Zone",
            "paramValue": "UTC",
            "description": "The timezone configured in the server, examples (1. UTC, 2. Asia/Jerusalem)",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "If defined - connector will extract the environment from the specified event field. You can manipulate the field data using the Regex pattern field to extract specific string. In case the the extracted environment field and Siemplify environment name are not equal - you can map them in the map.json that is auto-generated on the first run, inside the <run-folder>.<run-folder> = C:\\Siemplify_Server\\Scripting\\SiemplifyConnectorExecution<Connector_Folder>",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "60",
            "description": "The timeout limit (in seconds) for the python process running current script",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": "",
            "description": "If defined - the connector will implement the specific RegEx pattern on the data from \"envirnment field\" to extract specific string. For example - extract domain from sender's address: \"(?<=@)(\\S+$)\"",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "IMAP USE SSL",
            "paramValue": "true",
            "description": "Indicates whether to use ssl on connection or not.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Unread Emails Only",
            "paramValue": "true",
            "description": "If checked, pull only unread mails",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Mark Emails as Read",
            "paramValue": "false",
            "description": "If checked, mark mails as read after pulling them",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Attach Original EML",
            "paramValue": "true",
            "description": "If checked, attach the original message as eml file.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Offset Time In Days",
            "paramValue": "1",
            "description": "Max number of days to fetch mails since. e.g. 3",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Emails Per Cycle",
            "paramValue": "10",
            "description": "Max count of mails to pull in one cycle",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Exclusion Body Regex",
            "paramValue": "",
            "description": "Exclude emails for which body matches specified regex. For example '([N|n]ewsletter)|([O|o]ut of office)' finds all emails containing 'Newsletter' or 'Out of office' keywords.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Original Received Mail Prefix",
            "paramValue": "orig",
            "description": "Prefix to add to the extracted keys (to, from,subject,\u2026) from the original email received in the monitored mailbox.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Attached Mail File Prefix",
            "paramValue": "attach",
            "description": "Prefix to add to the extracted keys (to, from,subject,\u2026) from the attached mail file received with the email in the monitored mailbox.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Create a Separate Siemplify Alert per Attached Mail File?",
            "paramValue": "true",
            "description": "if enabled, connector will create multiple alerts, 1 alert per attached mail file. This behavior can be useful when processing email with multiple mail files attached and Siemplify event mapping set to create entities from attached mail file.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "IMAP Server Address",
            "paramValue": "imap.gmail.com",
            "description": "e.g. imap.gmail.com",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "IMAP Port",
            "paramValue": "993",
            "description": "Imap port. e.g. 993",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Username",
            "paramValue": "siemplifytesting.rodgonzalez@gmail.com",
            "description": "IMAP Username",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Password",
            "paramValue": "***************",
            "description": "IMAP Password",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Additional headers to extract from emails",
            "paramValue": "",
            "description": "Specify additional headers to search and extract from processed emails. Found headers will be added to the email\u2019s Siemplify event. Parameter accepts multiple values as a comma separated string, provided values can be set as an exact match or as a regex, for example, Received:, (Test).*",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Exclusion Subject Regex",
            "paramValue": "",
            "description": "Exclude emails for which subject matches specified. For example '([N|n]ewsletter)|([O|o]ut of office)' finds all emails containing 'Newsletter' or 'Out of office' keywords.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [
        "subject: (?<=Subject: ).*",
        "to: (?m)(?<=^To: ).*"
    ],
    "integrationVersion": 32.0,
    "isScriptConnector": true,
    "script": "# -*- coding: utf-8 -*-\nimport sys\nimport re\nimport base64\nimport os\nimport pytz\nimport datetime as dt\nfrom SiemplifyDataModel import Attachment\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom SiemplifyUtils import output_handler\nfrom EmailIMAPManager import EmailIMAPManager\nfrom EmailCommon import DEFAULT_REGEX_MAP, URLS_REGEX, safe_str_cast, build_regex_map, is_invalid_prefix, \\\n    InvalidParameterError, transform_dict_keys\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\nfrom TIPCommon import extract_script_param, get_last_success_time, save_timestamp, is_overflowed, read_ids, write_ids\nimport uuid\n\n\ndef create_siemplify_case_wall_attachment_object(full_file_name, file_contents):\n    # type: (bytes, str) -> Attachment\n    \"\"\"\n    Create attachment object with the original email\n    :param full_file_name: {string} File name of the attachment\n    :param file_contents: {string} Attachment content as a string\n    :return: {Attachment} of attachment object\n    \"\"\"\n\n    base64_blob = base64.b64encode(file_contents).decode()\n\n    file_name, file_extension = os.path.splitext(full_file_name)\n\n    attachment_object = Attachment(\n        case_identifier=None,\n        alert_identifier=None,\n        base64_blob=base64_blob,\n        attachment_type=file_extension,\n        name=file_name,\n        description=\"Original email attachment\",\n        is_favorite=False,\n        orig_size=len(file_contents),\n        size=len(base64_blob))\n\n    return attachment_object\n\n\nclass NewCaseBuilder(object):\n    \"\"\"\n    Builds New CaseInfo based on available data\n    \"\"\"\n    ATTACHMENT_DESCRIPTION = 'This is the original message as EML'\n    EMAIL_EML_RESOLUTION = '.eml'\n    EMAIL_MSG_RESOLUTION = '.msg'\n    EMAIL_ICS_RESOLUTION = '.ics'\n    DEFAULT_NAME = \"Monitored Mailbox <{0}>\"\n    DEFAULT_PRIORITY = 40  # Defaulting to Low.\n    DEFAULT_TIMESTAMP = 1\n    DEFAULT_VENDOR_NAME = \"Mail\"\n    DEFAULT_PRODUCT_NAME = \"Mail\"\n    DEFAULT_SUBJECT_TEXT = \"Message Has No Subject\"\n    DEFAULT_MAIL_ADDRESS = \"Undefined\"\n    DEFAULT_EMAIL_NAME = \"{0}_{1}\"\n    DEFAULT_EML_FILE_NAME = \"{0}.eml\"\n    EVENTS_SYSTEM_KEYS = ['device_product', 'event_name', 'original_message_id', 'event_type', 'vendor',\n                          'event_name_mail_type', 'monitored_mailbox_name']\n\n    def __init__(self,\n                 email,\n                 siemplify,\n                 logger,\n                 env_default,\n                 mail_address=None,\n                 env_field_name=None,\n                 env_field_regex=None,\n                 product_field=None,\n                 ):\n        \"\"\"\n        Basic constructor\n        :param email: {EmailDataModels.EmailModel} EmailModel instance with fulfilled email parameters\n        :param logger: {Siemplify.LOGGER} Logger instance\n        :param env_default: {str} Default environment name\n        :param mail_address: {str} Email address of the current monitored mailbox\n        :param env_field_name: {str} Email field name, which may contain information on environment, which will be extracted by the regex present in env_field_regex field.\n        :param env_field_regex: {str} Regex to extract actual environment name from the env_field_name\n        :param product_field: {str} Product_field to use (if given)\n        \"\"\"\n        self.email = email\n        self.siemplify = siemplify\n        self.logger = logger\n        self.mail_address = mail_address\n        if not self.mail_address:\n            self.mail_address = self.DEFAULT_MAIL_ADDRESS\n        self.env_default = env_default\n        self.env_field_name = env_field_name\n        self.env_field_regex = env_field_regex\n        self.product_field = product_field\n\n        self.environment_handle = GetEnvironmentCommonFactory.create_environment_manager(\n            siemplify,\n            self.env_field_name,\n            self.env_field_regex\n        )\n\n        self.case = CaseInfo()\n        self.case.attachments = []\n\n    def create_case(self, prefix=None, is_original_mail=False, additional_events=None):\n        \"\"\"\n        Fills in case common information\n        :param prefix: {str} Prefix for events\n        :param is_original_mail: {bool} Specifies if provided mail is the original one or no\n        :param additional_events: {list} List of additional event for the case\n        \"\"\"\n        self.logger.info(\"NewCaseBuilder.create_case() - Start\")\n        # Create the CaseInfo\n        if not self.email.message_id:\n            raise AttributeError(\"Email().message_id is None or empty.\")\n        default_mailbox = self.DEFAULT_NAME.format(self.mail_address)\n        timestamp = self.email.unixtime_date\n        email_name = self.DEFAULT_EMAIL_NAME.format(self.mail_address, self.email.unixtime_date)\n\n        self.case.identifier = self.email.message_id\n        self.case.ticket_id = self.email.message_id\n        self.case.display_id = self.email.message_id if is_original_mail else str(uuid.uuid4())\n        self.case.name = email_name\n        self.case.rule_generator = default_mailbox\n        self.case.start_time = timestamp\n        self.case.end_time = timestamp\n        self.case.priority = self.DEFAULT_PRIORITY\n        self.case.device_vendor = self.DEFAULT_VENDOR_NAME\n        self.case.device_product = self.product_field if self.product_field else self.DEFAULT_PRODUCT_NAME\n        self.email.event_name = self.case.name\n        self.case.events = [transform_dict_keys(\n            original_dict=self.email.to_dict(as_event=True, is_original_mail=is_original_mail),\n            prefix=prefix,\n            keys_to_except=self.EVENTS_SYSTEM_KEYS)\n        ]\n\n        if additional_events:\n            self.case.events.extend(additional_events)\n\n        self.logger.info(\"NewCaseBuilder.create_case() - Finish\")\n\n    def update_environment(self):\n        \"\"\"\n        Update environment information for the case\n        \"\"\"\n        self.logger.info(\"NewCaseBuilder.update_environment() - Start\")\n        self.case.environment = self.environment_handle.get_environment(self.case.events[0])\n        self.logger.info(\"NewCaseBuilder.update_environment() - Finish\")\n\n    def attach_original_email(self):\n        \"\"\"\n        Attaches original email to the case\n        \"\"\"\n        self.logger.info(\"NewCaseBuilder.attach_original_email() - Start\")\n\n        if not self.email.original_message:\n            self.logger.info(\"EmailModel().original_message is None or empty - unable to attach it.\")\n            return\n        if not self.email.subject:\n            self.logger.info(\"EmailModel().subject is None or empty - unable to attach original_message.\")\n            return\n\n        try:\n            attachment_object = create_siemplify_case_wall_attachment_object(\n                self.DEFAULT_EML_FILE_NAME.format(self.email.subject),\n                self.email.original_message.encode())\n\n            # Add to case_info\n            self.case.attachments.append(attachment_object)\n\n            self.logger.info(\"Successfully attached original message as EML.\")\n            self.logger.info(\"NewCaseBuilder.attach_original_email() - Finish\")\n        except Exception as e:\n            self.logger.error(\"Failed to attach original EML for email={0}\".format(self.email.email_uid))\n            self.logger.exception(e)\n\n    def attach_emails(self, prefix=None):\n        \"\"\"\n        Adds all attached emails to events\n        \"\"\"\n        for index, email in enumerate(self.email.attached_emails):\n            try:\n                email.original_message_id = self.case.identifier\n                email.event_name = self.case.name\n                self.case.events.append(transform_dict_keys(\n                    original_dict=email.to_dict(as_event=True, is_original_mail=False),\n                    prefix=prefix,\n                    suffix=index+1,\n                    keys_to_except=self.EVENTS_SYSTEM_KEYS))\n                self.logger.info(\n                    \"Attached {0} to the case as another event.\".format(email.message_id))\n            except Exception as e:\n                self.logger.error(\"Unable to attach email {0} as another event\".format(email.message_id))\n                self.logger.exception(e)\n\n    def attach_files(self):\n        \"\"\"\n        Attaches all email attachments with exception of emails to the case\n        \"\"\"\n        for attachment in self.email.attachments:\n            try:\n                if self.EMAIL_EML_RESOLUTION not in attachment.file_name.lower() and \\\n                        self.EMAIL_MSG_RESOLUTION not in attachment.file_name.lower() and \\\n                        self.EMAIL_ICS_RESOLUTION not in attachment.file_name.lower():\n                    self.logger.info(\"Trying to attach file to case: {}\".format(attachment.file_name))\n                    packed_attachment = create_siemplify_case_wall_attachment_object(\n                        attachment.file_name,\n                        attachment.file_contents\n                    )\n                    self.case.attachments.append(packed_attachment)\n                    self.logger.info(\n                        \"Attached {} to the case as a file.\".format(attachment.file_name))\n            except Exception as e:\n                self.logger.error(\"Unable to attach {0} to the case\".format(attachment.file_name))\n                self.logger.exception(e)\n\n    def get_case(self):\n        \"\"\"\n        Returns filled in case instance\n        :return: {CaseInfo} Filled in case instance\n        \"\"\"\n        return self.case\n\n\nclass BaseEmailConnector(object):\n    \"\"\"\n    Base class for EmailConnector containing most common functionality\n    \"\"\"\n\n    DEFAULT_OFFSET_IN_DAYS = 5\n    DEFAULT_MAX_EMAILS_PER_CYCLE = 10\n\n    def __init__(self, config=None, is_test=False, connector_name=None):\n        \"\"\"\n        Common constructor for BaseEmailConnector\n        \"\"\"\n        self.connector_scope = SiemplifyConnectorExecution()\n        self.connector_scope.script_name = connector_name\n        self.logger = self.connector_scope.LOGGER\n        self.environment_name = self.connector_scope.context.connector_info.environment\n\n        self.is_test = is_test\n        if self.is_test:\n            self.logger.info(\"***** This is an \\\"IDE Play Button\\\"\\\\\\\"Run Connector once\\\" test run ******\")\n\n        self._load_connector_configuration(config)\n        self._load_connector_whitelist_rules()\n        self._initialize_managers()\n\n    def _get_connector_param(self, param_name, config, default_value=None, input_type=str, is_mandatory=False, print_value=False):\n        return extract_script_param(\n            siemplify=self.connector_scope,\n            input_dictionary=config,\n            param_name=param_name,\n            default_value=default_value,\n            input_type=input_type,\n            is_mandatory=is_mandatory,\n            print_value=print_value)\n\n    def _load_connector_configuration(self, config):\n        \"\"\"\n        Loads all connector configurations from Siemplify\n        \"\"\"\n        self.logger.info(\"==================== Main - Param Init ====================\")\n\n        conf = self.connector_scope.parameters if not config else config\n        self.imap_host = self._get_connector_param(param_name=\"IMAP Server Address\",\n                                                   config=conf,\n                                                   is_mandatory=True)\n        self.imap_port = self._get_connector_param(param_name=\"IMAP Port\",\n                                                   config=conf,\n                                                   input_type=int,\n                                                   is_mandatory=True)\n        self.imap_use_ssl = self._get_connector_param(param_name=\"IMAP USE SSL\",\n                                                      config=conf,\n                                                      input_type=bool,\n                                                      is_mandatory=True)\n        self.username = self._get_connector_param(param_name=\"Username\",\n                                                  config=conf,\n                                                  is_mandatory=True)\n        self.password = self._get_connector_param(param_name=\"Password\",\n                                                  config=conf,\n                                                  is_mandatory=True)\n\n        folders_string = self._get_connector_param(param_name=\"Folder to check for emails\",\n                                                   config=conf,\n                                                   is_mandatory=True)\n        self.folders = [f.strip() for f in folders_string.split(\",\")] if folders_string else []\n\n        self.offset_in_days = self._get_connector_param(param_name=\"Offset Time In Days\",\n                                                        config=conf,\n                                                        input_type=int,\n                                                        default_value=self.DEFAULT_OFFSET_IN_DAYS)\n        self.max_emails_per_cycle = self._get_connector_param(param_name=\"Max Emails Per Cycle\",\n                                                              config=conf,\n                                                              input_type=int,\n                                                              default_value=self.DEFAULT_MAX_EMAILS_PER_CYCLE)\n        self.attach_original_eml = self._get_connector_param(param_name=\"Attach Original EML\",\n                                                             config=conf,\n                                                             input_type=bool,\n                                                             default_value=False)\n        self.unread_only = self._get_connector_param(param_name=\"Unread Emails Only\",\n                                                     config=conf,\n                                                     input_type=bool,\n                                                     default_value=False)\n        self.mark_as_read = self._get_connector_param(param_name=\"Mark Emails as Read\",\n                                                      config=conf,\n                                                      input_type=bool,\n                                                      default_value=False)\n        self.server_time_zone = self._get_connector_param(param_name=\"Server Time Zone\",\n                                                          config=conf,\n                                                          default_value='UTC')\n        self.environment_field_name = self._get_connector_param(param_name=\"Environment Field Name\",\n                                                                config=conf)\n        self.environment_regex = self._get_connector_param(param_name=\"Environment Regex Pattern\",\n                                                           config=conf)\n        self.proxy_server = self._get_connector_param(param_name=\"Proxy Server Address\",\n                                                      config=conf)\n        self.proxy_username = self._get_connector_param(param_name=\"Proxy Username\",\n                                                        config=conf)\n        self.proxy_password = self._get_connector_param(param_name=\"Proxy Password\",\n                                                        config=conf)\n        self.product_field = self._get_connector_param(param_name=\"DeviceProductField\",\n                                                        config=conf)\n        self.headers_to_add_to_events = self._get_connector_param(\n            param_name='Additional headers to extract from emails',\n            config=conf)\n        self.headers_to_add_to_events = [header.strip()\n                                         for header in self.headers_to_add_to_events.split(',')\n                                         if header and header.strip()] if self.headers_to_add_to_events else []\n        self.subject_exclude_regex = self._get_connector_param(param_name=\"Exclusion Subject Regex\", config=conf)\n        self.body_exclude_regex = self._get_connector_param(param_name=\"Exclusion Body Regex\", config=conf)\n\n        self.original_mail_prefix = self._get_connector_param(param_name=\"Original Received Mail Prefix\", config=conf,\n                                                              print_value=True)\n        self.attached_mail_prefix = self._get_connector_param(param_name=\"Attached Mail File Prefix\", config=conf,\n                                                              print_value=True)\n        self.alert_per_attachment = self._get_connector_param(param_name=\"Create a Separate Siemplify Alert per \"\n                                                                         \"Attached Mail File?\",\n                                                              config=conf, input_type=bool, print_value=True)\n\n    def _load_connector_whitelist_rules(self):\n        \"\"\"\n        Loads regex map from whitelist rules in order to extract information from emails and include it to event.\n        \"\"\"\n        whitelist_rules = self.connector_scope.whitelist if self.connector_scope.whitelist else []\n        self.logger.info(\"Current whitelist rules are: {}\".format(whitelist_rules))\n\n        self.regex_map = DEFAULT_REGEX_MAP\n        if whitelist_rules:\n            self.regex_map = build_regex_map(whitelist_rules)\n\n        self.logger.info(\"The current regex map is: {}\".format(self.regex_map))\n\n    def _initialize_managers(self):\n        \"\"\"\n        Abstract method to initialize all required managers\n        \"\"\"\n        raise NotImplementedError()\n\n    def is_matching_exclude_patterns(self, message, subject_exclude_pattern=None, body_exclude_pattern=None):\n        \"\"\"\n        Determine if message body matching provided regexp\n        :param message: {EmailDataModels.EmailModel} Message object\n        :param subject_exclude_pattern: {str} Regex pattern, which would exclude emails with matching subject.\n        :param body_exclude_pattern: {str} Regex pattern, which would exclude emails with matching body.\n        :return: {bool} True if matches one of the exclude patterns; False - otherwise.\n        \"\"\"\n        body_parts = [message.html_body, message.text_body, message.body]\n\n        if body_exclude_pattern:\n            for part in body_parts:\n                if part and re.findall(body_exclude_pattern, part):\n                    return True\n\n        if subject_exclude_pattern:\n            if message.subject and re.findall(subject_exclude_pattern, message.subject):\n                return True\n\n        return False\n\n    def get_server_localized_time(self, dt_timestamp):\n        \"\"\"Transforms datetime timestamp into correct server timezone\n\n        Args:\n            dt_timestamp (datetime.datetime): datetime timestamp to convert\n\n        Returns:\n            datetime.datetime: datetime timestamp in the server timezone\n\n        Raises:\n            InvalidParameterError: Unknown server time zone\n        \"\"\"\n        try:\n            tz = pytz.timezone(self.server_time_zone)\n            return dt_timestamp.astimezone(tz)\n        except pytz.UnknownTimeZoneError as e:\n            raise InvalidParameterError(\n                f\"Invalid Server TimeZone provided: {self.server_time_zone}\"\n            ) from e\n\n    def run(self):\n        \"\"\"\n        Main method of Connector execution. It uses template pattern.\n        \"\"\"\n        self.logger.info(\"------------------- Main - Started -------------------\")\n\n        try:\n            if self.original_mail_prefix and is_invalid_prefix(self.original_mail_prefix):\n                raise InvalidParameterError(\"Original Received Mail Prefix configured contains a space, which is not \"\n                                            \"supported, please remove any spaces and try again.\")\n\n            if self.attached_mail_prefix and is_invalid_prefix(self.attached_mail_prefix):\n                raise InvalidParameterError(\"Attached Mail File Prefix configured contains a space, which is not \"\n                                            \"supported, please remove any spaces and try again.\")\n\n            last_calculated_run_time = get_last_success_time(siemplify=self.connector_scope,\n                                                             offset_with_metric={'days': self.offset_in_days})\n            self.logger.info(\"Calculated last run time. Last run time is: {}\".format(last_calculated_run_time))\n            self.logger.info(\"Last execution time: {}\".format(last_calculated_run_time))\n\n            server_start_time = self.get_server_localized_time(\n                last_calculated_run_time\n            )\n            self.logger.info(\n                \"Using IMAP server timezone, fetching Emails from: {}\".format(\n                    server_start_time\n                )\n            )\n\n            # Read already existing email ids\n            existing_ids = read_ids(self.connector_scope)\n            self.connector_scope.LOGGER.info(f\"Successfully loaded {len(existing_ids)} existing ids\")\n\n            alerts = []\n            for index, alert_id in enumerate(self._search_alerts(server_start_time), 1):\n                try:\n                    if self.is_test and index > 1:\n                        self.logger.info(\"As this is a test run, limiting number of alerts processed to 1.\")\n                        break\n\n                    if len(alerts) >= self.max_emails_per_cycle:\n                        # Provide slicing for the alerts amount.\n                        self.connector_scope.LOGGER.info(\n                            \"Reached max number of emails cycle. No more emails will be processed in this cycle.\"\n                        )\n                        break\n\n                    email_alerts = self._fetch_alert(alert_id, existing_ids)\n\n                    if email_alerts:\n                        alerts.extend([email_alert for email_alert in email_alerts if email_alert])\n\n                        if self.alert_per_attachment and len(email_alerts) > 1:\n                            self.logger.info(\"Added Alert {} and Alerts per attached mail files to package results\"\n                                             .format(alert_id))\n                        else:\n                            self.logger.info(\"Added Alert {} to package results\".format(alert_id))\n\n                except Exception as e:\n                    self.logger.error(\"Failed to process alert {}\".format(alert_id))\n                    self.logger.exception(e)\n\n            if not self.is_test:\n                self.connector_scope.LOGGER.info(\"Saving existing ids.\")\n                write_ids(self.connector_scope, existing_ids)\n                save_timestamp(self.connector_scope, alerts, 'end_time')\n\n        except Exception as e:\n            self.logger.error(f\"Got exception on main handler. Error: {e}\")\n            self.logger.exception(e)\n\n            if self.is_test:\n                raise\n\n        self.logger.info(\"------------------- Main - Finished -------------------\")\n        self.connector_scope.return_package(alerts)\n\n    def _search_alerts(self, last_run_time):\n        raise NotImplementedError()\n\n    def _fetch_alert(self, alert_id, existing_ids):\n        raise NotImplementedError()\n\n\nclass EmailConnector(BaseEmailConnector):\n    \"\"\"\n    Class wrapping logic of EmailConnector.\n    \"\"\"\n    CONNECTOR_NAME = \"EmailConnector\"\n    PRODUCT_NAME = VENDOR_NAME = \"Mail\"\n\n    def __init__(self, config=None, is_test=False):\n        # type: (dict, bool) -> None\n        \"\"\"\n        Default constructor for the EmailConnector\n        :param is_test: Runs email collection in a limited manner in test purposes\n        \"\"\"\n        super(EmailConnector, self).__init__(\n            config=config,\n            is_test=is_test,\n            connector_name=self.CONNECTOR_NAME)\n\n    def _initialize_managers(self):\n        # type: () -> None\n        \"\"\"\n        Initializes EmailIMAPManager and EmailSMTPManager\n        \"\"\"\n\n        self.logger.info(\"Connecting to Email manager\")\n        self.email_imap_manager = EmailIMAPManager(\n            mail_address=self.username,\n            logger=self.logger,\n            environment=self.environment_name,\n            regex_map=self.regex_map,\n            proxy_server=self.proxy_server,\n            proxy_username=self.proxy_username,\n            proxy_password=self.proxy_password\n        )\n\n        self.logger.info(\"Login to IMAP\")\n        self.email_imap_manager.login_imap(\n            host=self.imap_host,\n            port=self.imap_port,\n            username=self.username,\n            password=self.password,\n            use_ssl=self.imap_use_ssl)\n\n    def _search_alerts(self, last_run_time):\n        \"\"\"\n        Override of an abstract method, which searches for emails to retrieve\n        :param last_run_time: {arrow.datetime} Emails should be retrieved after this timestamp\n        :return: {tuple} returning a tuple of (folder, email_id) values.\n        \"\"\"\n        for folder in self.folders:\n            try:\n                filtered_mails_ids = self.email_imap_manager.receive_mail_ids(\n                    folder_name=folder,\n                    time_filter=last_run_time,\n                    only_unread=self.unread_only)\n\n                for email_uid in filtered_mails_ids:\n                    # I may search through multiple mailboxes, thus in order to retrieve email later on,\n                    # I need to know not only it's sequential number, but also it's folder\n                    yield folder, email_uid\n\n            except Exception as e:\n                self.logger.error(\"Failed to search for emails in the folder={0}\".format(folder))\n                self.logger.exception(e)\n\n        self.logger.info(\"Found {} emails.\".format(len(filtered_mails_ids)))\n\n    def is_matching_filter_patterns(self, email):\n        \"\"\"\n        Is email subject and body matching to exclude patterns\n        :param email: {EmailDataModels.EmailModel}\n        :return {bool}:\n        \"\"\"\n        if self.subject_exclude_regex or self.body_exclude_regex:\n            if self.is_matching_exclude_patterns(email, self.subject_exclude_regex, self.body_exclude_regex):\n                # Excluded email with pattern should stay unread\n                self._mark_email_as_read(email_id=email.email_uid, mark_as_read=False)\n                self.logger.info(\"Email with message_id={} was ignored after filtering by regexes\"\n                                 .format(email.message_id))\n                return False\n\n        return True\n\n    def _fetch_alert(self, alert_id, existing_ids):\n        \"\"\"\n        Override of an abstract method, which fetches full details of email by it's ID.\n        Afterwards does all required processing to build a case\n        :param alert_id: {tuple} (folder_name, email_uid)\n        :param existing_ids: {list} List of already existing ids\n        :return: {CaseInfo} An instance of resulting CaseInfo()\n        \"\"\"\n        self.logger.info(\"-------------- Started processing Alert {}\".format(alert_id), alert_id=alert_id)\n\n        # Unpacking alert_id into folder and according email_uid\n        folder, email_uid = alert_id\n        self.logger.info(\"Fetching email with email_uid={0} in folder={1}\".format(\n            email_uid, folder), alert_id=alert_id)\n\n        # Retrieve email object along with all it's attachments\n        email = self.email_imap_manager.get_message_data_by_message_id(\n            email_uid=email_uid,\n            folder_name=folder,\n            include_raw_eml=self.attach_original_eml,\n            mark_as_read=self.mark_as_read,\n            additional_headers=self.headers_to_add_to_events\n        )\n\n        if email.message_id in existing_ids:\n            self.logger.info(f\"The email with email_uid={email_uid} in folder={folder} skipped since it has been \"\n                             f\"fetched before\", alert_id=alert_id)\n            return None\n\n        if not email:\n            self.logger.error(\"No emails were found for email_uid={0} in folder={1}\".format(\n                email_uid, folder), alert_id=alert_id)\n            return None\n        self.logger.info(\"Fetched email successfully with email_uid={0} and message_id={1}\".format(\n            email_uid, email.message_id), alert_id=alert_id)\n\n        existing_ids.append(email.message_id)\n\n        if not self.is_matching_filter_patterns(email):\n            self._mark_email_as_read(email.email_uid, self.mark_as_read)\n            return None\n\n        # Create case info\n        cases = self._create_cases_info(email)\n        self.logger.info(\n            \"Created case on the base of email.message_id={}\".format(email.message_id), alert_id=alert_id)\n\n        for index, case in enumerate(cases):\n            if is_overflowed(self.connector_scope, case, self.is_test):\n                self.logger.info(\n                    '{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.'\n                        .format(alert_name=str(case.rule_generator),\n                                alert_identifier=str(case.ticket_id),\n                                environment=str(case.environment),\n                                product=str(case.device_product)))\n                self.logger.info(\"Current case is overflow.\", alert_id=alert_id)\n                self.logger.error(\"Alert with alert_id={} found as overflow alert. Skipping.\".format(alert_id))\n                cases.pop(index)\n\n        self._mark_email_as_read(email.email_uid, self.mark_as_read)\n\n        self.logger.info(\"-------------- Finished processing Alert {}\".format(alert_id), alert_id=alert_id)\n\n        return cases\n\n    def _create_case_info(self, email, is_original_mail=False, additional_events=None):\n        \"\"\"\n        Create Case instance based on extracted Event\n        :param email: {dict} EmailDataModels.EmailModel() instance\n        :param is_original_mail: {bool} Specifies if provided mail is the original one or no\n        :param additional_events: {list} List of additional events for the case\n        :return: {CaseInfo} case\n        \"\"\"\n        self.logger.info(\"Start case creation\")\n        # Validate email message id exists\n        email_id = email.message_id\n        if not email_id:\n            raise AttributeError(\"Found mail, cannot get its message id\")\n\n        builder = NewCaseBuilder(\n            email,\n            self.connector_scope,\n            self.logger,\n            self.environment_name,\n            self.email_imap_manager.mail_address,\n            self.environment_field_name,\n            self.environment_regex,\n            self.product_field\n        )\n        prefix = self.original_mail_prefix if is_original_mail else self.attached_mail_prefix\n        additional_events = additional_events if additional_events else []\n        builder.create_case(prefix, is_original_mail, additional_events)\n        builder.update_environment()\n\n        if is_original_mail:\n            if self.attach_original_eml:\n                builder.attach_original_email()\n\n            if not self.alert_per_attachment:\n                builder.attach_emails(self.attached_mail_prefix)\n\n            builder.attach_files()\n\n        res = builder.get_case()\n\n        self.logger.info(\"Created case: {}\".format(res))\n\n        return res\n\n    def _create_cases_info(self, email):\n        \"\"\"\n        Create Cases instances based on extracted email and its email attachments\n        :param email: {dict} EmailDataModels.EmailModel() instance\n        :return: {list} List of CaseInfo\n        \"\"\"\n        cases = [self._create_case_info(email, is_original_mail=True)]\n\n        if self.alert_per_attachment and email.attached_emails:\n            for attached_email in email.attached_emails:\n                cases.append(self._create_case_info(attached_email, additional_events=[cases[0].events[0]]))\n\n        return cases\n\n\n    def _mark_email_as_read(self, email_id, mark_as_read):\n        # type: (str, bool) -> None\n        \"\"\"\n        Allows to mark read email via IMAP\n        :param email_id: {str} Email unique identifier\n        :param mark_as_read: {bool} If True, email should be marked as read on the server\n        \"\"\"\n        try:\n            # Mark specific email as read/unread because fetching emails automatically mark them as read.\n            # Mark the mail as read only if succeeded creating case.\n            self.email_imap_manager.mark_email_as_read(email_id, mark_as_read)\n        except Exception as e:\n            self.logger.error(\n                \"Failed to mark email as read. Error message: {}\".format(str(e)))\n            self.logger.exception(e)\n            if self.is_test:\n                raise\n\n\n@output_handler\ndef main(is_test=False):\n    email_connector = EmailConnector(is_test=is_test)\n    email_connector.run()\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print(\"Main execution started\")\n        main()\n    else:\n        print(\"Test execution started\")\n        main(is_test=True)\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/email-v2#connectors",
    "deviceProductField": "Mail",
    "eventNameField": "event_name_mail_type",
    "connectorStatus": {
        "connectorIdentifier": "Generic IMAP Email Connector_055e3705-f92d-46d5-8f27-56eedf174c78",
        "connectivityStatus": 1,
        "amountAlertsInLastDay": 4,
        "avgAlertsPerDay": 4
    },
    "isNew": false,
    "agentIdentifier": null
}